/// <reference path="../typings/tsd.d.ts" />

if (Meteor.isServer) {
  Meteor.npmRequire('reflect-metadata');
}

export const SampleClassDecorator: ClassDecorator = function(target) {
  // console.log(`SampleClassDecorator for ${typeof target}:`);
  // console.log(target);
  // console.log();
  return target;
};

class ServerMethodHelper {
  private serverMethodName: string;

  constructor(
    private target: Object,
    private methodName: string,
    private descriptor: TypedPropertyDescriptor<Function>, customMethodName?: string) {
    this.serverMethodName = customMethodName || this.getServerMethodName();
  }

  getCorrectDescriptor(): TypedPropertyDescriptor<Function> {
    if (Meteor.isClient) {
      this.descriptor.value = this.createProxyToServer();
    }
    return this.descriptor;
  }

  registerServerMethod() {
    let serverMethod = {};

    serverMethod[this.serverMethodName] = this.createServerMethod();
    Meteor.methods(serverMethod);
  }

  private createProxyToServer(): Function {
    let serverMethodName = this.serverMethodName;

    return function() {
      let methodArgs: any = arguments;

      // Meteor.call and Meteor.apply use callback function
      // this way a promise is returned instead,
      // which will eventaully resolve to the result of the method.
      return new Promise((resolve, reject) => {
        Meteor.apply(serverMethodName, methodArgs, null, (err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
      });
    };
  }

  private createServerMethod(): Function {
    let paramChecks = this.getParamChecks();
    let originalMethod = this.descriptor.value;

    return function() {
      // START - checking input parameters
      for (let i = 0; i < paramChecks.length; i++) {
        if (i >= arguments.length) {
          throw new Match.Error(
            `Found ${arguments.length} arguments, expected at least ${paramChecks.length}`);
        }
        // else
        if (paramChecks[i]) {
          paramChecks[i](arguments[i]);
        }
      }
      // END - checking input parameters
      return originalMethod.apply(this, arguments);
    };
  }

  private getParamChecks() {
    let paramTypes = this.getParamTypes() || [];
    let ret: Function[] = [];

    for (let i = 0; i < paramTypes.length; i++) {
      ret.push(this.getParamCheck(paramTypes[i], i));
    }
    return ret;
  }

  private getParamCheck(type: any, index: number): Function {
    let paramCheck = this.getCustomValidation(index)

    if (paramCheck) {
      if (paramCheck.checkAny) {
        return function(val) {
          // go through all patterns, the first one which fits can exit the function
          for (let pattern of paramCheck.validation) {
            if (Match.test(val, pattern)) { return true; }
          }
          // if no pattern fits, throw Match.Error
          throw new Match.Error(paramCheck.errorMsg);
        };
      } else {
        return function(val) { check(val, paramCheck.validation); };
      }
    } else {
      return this.getDefaultValidation(type);
    }
  }

  private getCustomValidation(paramIndex: number) {
    let targetKey = `${this.methodName}.${paramIndex}`;
    let customValidation = Reflect.getMetadata('check:validation', this.target, targetKey);

    if (customValidation) {
      return {
        validation: <any | any[]>customValidation,
        checkAny: Match.test(customValidation, [Match.Any]),
        errorMsg: <string>Reflect.getMetadata('check:validation.errorMsg', this.target, targetKey)
      };
    } else {
      return null;
    }
  }

  private getDefaultValidation(type: any): Function {
    if (type === Array) {
      return function(val) { check(val, [Match.Any]); };
    } else if (type === Object) {
      return function(val) { check(val, Match.Any); };
    } else {
      return function(val) { check(val, type); };
    }
  }

  private getParamTypes(): any[] {
    return Reflect.getMetadata('design:paramtypes', this.target, this.methodName);
  }

  private getServerMethodName(): string {
    return `_autoGenerated.${this.getClassName() }.${this.methodName}`;
  }

  private getClassName(): string {
    if (this.target.constructor) {
      const funcNameRegex = /function (.{1,})\(/;
      let res = funcNameRegex.exec(this.target.constructor.toString());

      if (res && res.length > 1) {
        return res[1];
      }
    }
    // else
    return 'undefinedClassName';
  }
}

export function ServerMethod(customMethodName?: string): MethodDecorator {
  return (target: Object, methodName: string, descriptor: TypedPropertyDescriptor<any>) => {
    let helper = new ServerMethodHelper(target, methodName, descriptor, customMethodName);

    helper.registerServerMethod();
    return helper.getCorrectDescriptor();
  };
}

export function Check(pattern: any): ParameterDecorator {
  return (target, propertyKey, parameterIndex) => {
    let metadataKey = 'check:validation';
    let metadataValue = pattern;
    let targetKey = `${propertyKey}.${parameterIndex}`;

    Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
  };
}

export function CheckAny(errorMsg: string, ...patterns: any[]): ParameterDecorator {
  return (target, propertyKey, parameterIndex) => {
    let metadataKey = 'check:validation';
    let metadataValue = patterns;
    let targetKey = `${propertyKey}.${parameterIndex}`;

    Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
    Reflect.defineMetadata(`${metadataKey}.errorMsg`, errorMsg, target, targetKey);
  };
}