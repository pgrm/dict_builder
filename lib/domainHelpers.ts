/// <reference path="../typings/tsd.d.ts" />

import {TypeChecksHelper} from 'lib/paramChecks';
import {ServerMethodsBase} from 'lib/baseClasses';

export function getTransformFunction(constructor: new () => any) {
  return (item: any) => {
    let ret = new constructor();

    Object.assign(ret, item);
    return ret;
  };
}

export function getCollectionOptions(
  constructor: new () => any, additionalOptions?: { connection?: Object; idGeneration?: string; }) {
  let ret: {
    connection?: Object,
    idGeneration?: string,
    transform?: Function
  } = additionalOptions || {};

  ret.transform = getTransformFunction(constructor);
  return ret;
}

export class ServerMethodHelper extends TypeChecksHelper {
  private serverMethodName: string;

  constructor(
    target: Object, methodName: string, descriptor: TypedPropertyDescriptor<Function> | Function,
    private className: string, customMethodName?: string, private autoResume = true) {
    super();
    super.initialize(target, methodName, descriptor);
    this.serverMethodName = customMethodName || this.getServerMethodName();
  }

  registerServerMethod() {
    if (Meteor.isClient && this.isServerOnlyMethod()) { return; }
    let serverMethod = {};

    serverMethod[this.serverMethodName] = this.getDescriptor().value;
    Meteor.methods(serverMethod);

    if (Meteor.isClient && this.autoResume && this.isGroundDbInstalled()) {
      Ground.methodResume(this.serverMethodName);
    }
  }

  getProxiedDescriptor(): TypedPropertyDescriptor<Function> {
    let newDescriptor = Object.assign({}, this.descriptor,
      { value: this.createProxyToServer() });
    return newDescriptor;
  }

  createProxyToServer(): Function {
    let serverMethodName = this.serverMethodName;

    return function(...args) {
      // Meteor.call and Meteor.apply use callback function,
      // when called from the client (connection != null)
      // this way a promise is returned instead,
      // which will eventaully resolve to the result of the method.

      const self = <ServerMethodsBase>this;

      if (self.connection) {
        return new Promise((resolve, reject) => {
          Meteor.apply(serverMethodName, args, null, (err, result) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        });
      } else {
        return Meteor.apply(serverMethodName, args);
      }
    };
  }

  private isServerOnlyMethod(): boolean {
    const metadataKey = 'security:serverOnly';
    const targetKey = this.methodName;

    return Reflect.getMetadata(metadataKey, this.target, targetKey);
  }

  private getServerMethodName(): string {
    return `_autoGenerated.${this.className}.${this.methodName}`;
  }

  private isGroundDbInstalled(): boolean {
    return ((typeof Ground !== 'undefined') && !!Ground.methodResume);
  }
}

export function ServerMethod(className: string, customMethodName?: string): MethodDecorator {
  return (target: Object, methodName: string, descriptor: TypedPropertyDescriptor<Function>) => {
    let helper =
      new ServerMethodHelper(target, methodName, descriptor, className, customMethodName);

    helper.registerServerMethod();
    return helper.getProxiedDescriptor();
  };
}
