/// <reference path="../typings/tsd.d.ts" />

import {TypeChecksHelper} from 'lib/paramChecks';

export function getTransformFunction(constructor: new () => any) {
  return function(item: any) {
    let ret = new constructor();

    Object.assign(ret, item);
    return ret;
  };
}

export function getCollectionOptions(
  constructor: new () => any, additionalOptions?: { connection?: Object; idGeneration?: string; }) {
  let ret: {
    connection?: Object,
    idGeneration?: string,
    transform?: Function
  } = additionalOptions || {};

  ret.transform = getTransformFunction(constructor);
  return ret;
}

class ServerMethodHelper extends TypeChecksHelper {
  private serverMethodName: string;
  private originalFunction: Function;

  constructor(
    target: Object, methodName: string, descriptor: TypedPropertyDescriptor<Function>,
    customMethodName?: string) {

    super(target, methodName, descriptor);
    this.serverMethodName = customMethodName || this.getServerMethodName();
    this.originalFunction = descriptor.value;
  }

  registerServerMethod() {
    let serverMethod = {};

    serverMethod[this.serverMethodName] = this.createServerMethod();
    Meteor.methods(serverMethod);
  }

  getCorrectDescriptor(): TypedPropertyDescriptor<Function> {
    if (Meteor.isClient) {
      this.descriptor.value = this.createProxyToServer();
    }
    return this.descriptor;
  }

  private createProxyToServer(): Function {
    let serverMethodName = this.serverMethodName;

    return function() {
      let methodArgs: any = arguments;

      // Meteor.call and Meteor.apply use callback function
      // this way a promise is returned instead,
      // which will eventaully resolve to the result of the method.
      return new Promise((resolve, reject) => {
        Meteor.apply(serverMethodName, methodArgs, null, (err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
      });
    };
  }

  private createServerMethod(): Function {
    let paramCheckFunction = this.getParamCheckFunction();
    let originalMethod = this.originalFunction;

    return function() {
      paramCheckFunction.apply(this, arguments);
      return originalMethod.apply(this, arguments);
    };
  }

  private getServerMethodName(): string {
    return `_autoGenerated.${this.getClassName() }.${this.methodName}`;
  }

  private getClassName(): string {
    if (this.target.constructor) {
      const funcNameRegex = /function (.{1,})\(/;
      let res = funcNameRegex.exec(this.target.constructor.toString());

      if (res && res.length > 1) {
        return res[1];
      }
    }
    // else
    return 'undefinedClassName';
  }
}

export function ServerMethod(customMethodName?: string): MethodDecorator {
  return (target: Object, methodName: string, descriptor: TypedPropertyDescriptor<Function>) => {
    let helper = new ServerMethodHelper(target, methodName, descriptor, customMethodName);

    helper.registerServerMethod();
    return helper.getCorrectDescriptor();
  };
}
