/// <reference path="../typings/tsd.d.ts" />

/* tslint:disable:forin */

import {ServerMethodsBase} from 'lib/baseClasses';
import {TypeChecksHelper} from 'lib/paramChecks';

export function getTransformFunction(constructor: new () => any) {
  return function(item: any) {
    let ret = new constructor();

    Object.assign(ret, item);
    return ret;
  };
}

export function getCollectionOptions(
  constructor: new () => any, additionalOptions?: { connection?: Object; idGeneration?: string; }) {
  let ret: {
    connection?: Object,
    idGeneration?: string,
    transform?: Function
  } = additionalOptions || {};

  ret.transform = getTransformFunction(constructor);
  return ret;
}

class ServerMethodHelper extends TypeChecksHelper {
  private serverMethodName: string;
  private descriptorHasBeenModified: boolean = false;

  constructor(
    target: Object, methodName: string, descriptor: TypedPropertyDescriptor<Function> | Function,
    private className: string, customMethodName?: string, private autoResume = true) {
    super();
    super.initialize(target, methodName, descriptor);
    this.serverMethodName = customMethodName || this.getServerMethodName();
  }

  registerServerMethod() {
    if (this.descriptorHasBeenModified) {
      throw new Error('The descriptor has already been modified. ' +
        'Call registerServerMethod before calling getCorrectDescriptor');
    }
    let serverMethod = {};

    serverMethod[this.serverMethodName] = this.getInterceptedFunction();
    Meteor.methods(serverMethod);

    if (Meteor.isClient && this.autoResume) {
      Ground.methodResume(this.serverMethodName);
    }
  }

  getCorrectDescriptor(): TypedPropertyDescriptor<Function> {
    if (Meteor.isClient) {
      this.descriptor.value = this.createProxyToServer();
      this.descriptorHasBeenModified = true;
    }
    return this.descriptor;
  }

  createProxyToServer(): Function {
    let serverMethodName = this.serverMethodName;

    return function() {
      let methodArgs: any = arguments;

      // Meteor.call and Meteor.apply use callback function
      // this way a promise is returned instead,
      // which will eventaully resolve to the result of the method.
      return new Promise((resolve, reject) => {
        Meteor.apply(serverMethodName, methodArgs, null, (err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
      });
    };
  }

  private getServerMethodName(): string {
    return `_autoGenerated.${this.className}.${this.methodName}`;
  }
}

export function ServerMethod(className: string, customMethodName?: string): MethodDecorator {
  return (target: Object, methodName: string, descriptor: TypedPropertyDescriptor<Function>) => {
    let helper =
      new ServerMethodHelper(target, methodName, descriptor, className, customMethodName);

    helper.registerServerMethod();
    return helper.getCorrectDescriptor();
  };
}

export class AutoServerMethods extends ServerMethodsBase {
  private methodsHaveBeenRegistered = false;

  constructor(private className: string, private loginRequired = true, autoRegister = true) {
    super();
    if (autoRegister) {
      this._registerAllMethods();
    }
  }

  protected _registerAllMethods() {
    if (this.methodsHaveBeenRegistered) {
      throw new Error(`Cannot register the methods of ${this.className} a second time.`);
    }
    this._forAllPublicMethods(this._registerMethod.bind(this));
  }

  protected _registerMethod(methodName: string) {
    let helper = new ServerMethodHelper(this, methodName, this[methodName], this.className);

    helper.registerServerMethod();
    if (Meteor.isClient) {
      this[methodName] = helper.createProxyToServer();
    }
  }

  private _forAllPublicMethods(action: (name: string) => void) {
    for (let pName in this) {
      let property = this[pName];

      if ((typeof property) === 'function' && !this._isPrivateMethod(pName)) {
        action(pName);
      }
    }
  }

  protected _isPrivateMethod(methodName: string): boolean {
    if (methodName && methodName.length > 0) {
      if (methodName[0] === '$' || methodName[0] === '_') {
        return true;
      } else {
        return this._shouldIgnoreMethod(methodName);
      }
    } else {
      return true;
    }
  }

  protected _shouldIgnoreMethod(methodName: string): boolean {
    return false;
  }
}
